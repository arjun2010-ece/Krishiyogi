Very important link of a simple classy project built with react and react-bootstrap
https://medium.com/bb-tutorials-and-thoughts/how-to-implement-different-layouts-in-react-38f3686b3388






CHECK FOR SCROLL IN A REACT APPLICATION:: TOGGLE BACKGROUND COLOR ON SCROLL
========================================

ITS MAJOR APPLICATION IS WHEN WE SCROLL DOWN THEN "NAVBAR" BACKGROUND COLOR CHANGES AND AS WE SCROLL UP TO THE TOP THEN IT AGAIN CHANGES.
OR IT TOGGLES THE BG COLOR ON SCROLL.

As scroll events are attached to window object so we can keep this code anywhere in any component, wherever we need, either in nested cor parent component.

  const [detectScroll, setDetectScroll] = useState(false)

  const handleScroll = (e) => {
    if(window.pageYOffset === 0) {
      setDetectScroll(false);
    }
    else{
      setDetectScroll(true);
    }    
  }

  useEffect(() => {
    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
  }, []);



VERY VERY IMPORTANT USE OF "Key" ATTRIBUTE IN REACTJS NOT IN A MAP FNS::
=======================================================================

Here in this code  a MODAL is called multiple times but not inside a MAP FN but a modal receives a STATE variable which keeps on changing based on NEXT/PREVIOUS
BUTTON state variable changes and so its data too changes.

In normal scenario without a key will work inside a modal whose value changes based on state variable.
but if you use animation library like reavt-reveal then animation will not work based on NEXT/PREVIOUS click and state variablle change.
For animation to work we need to use "Key" prop whenever state variable is mentioned.


import React, {useState, useEffect} from 'react';
import {Fade} from 'react-reveal';
import 'react-responsive-modal/styles.css';
import { Modal } from 'react-responsive-modal';

const App = () => {
  const [open, setOpen] = useState(false);
  const [effect, setEffect] = useState(false);
  const [index, setIndex] = useState(0);
  const [profile, setProfile] = useState({});

  const [profiles] = useState([
    {title: "First title", description: "It is first description"},
    {title: "Second title", description: "It is second description"},
    {title: "third title", description: "It is third description"},
  ]);

  const onOpenModal = (item) => {
    setProfile(item);
    setOpen(true);
  }

  const onCloseModal = () => setOpen(false);
  const handlePrev = () => {
    if(index > 0){
      let i = index - 1;
      setIndex(i);
      setProfile(profiles[i]);
    }
  }

  const handleNext = () => {
    if(index < profiles.length - 1){
      let i = index + 1;
      setIndex(i);
      setProfile(profiles[i]);
    }
  }

  return (
    <div>
      <h1>Application..............</h1>
      <div className="container">
        {
          profiles.map((p, i) => (
            <div key={i} className="item" onClick={() => onOpenModal(p)}>
              <h1>{p.title}</h1>
            </div>
          ))
        }
      </div>

      <Modal open={open} onClose={onCloseModal} center
        classNames={{
          overlay: 'customOverlay',
          modal: 'customModal',
        }}>
          <h2>Simple centered modal</h2>
            
              <Fade bottom delay={700} key={profile.title}> // based on this "key" attribute it forces animation from next/previous btn click
	      						    // as profile.title is used here.
                <h5>
                    {profile.title}
                </h5>
              </Fade>

            
              <Fade bottom delay={800} key={profile.description}> // based on this "key" attribute it forces animation from next/previous btn click
	      							// as profile.description is used here.
                <p>
                  {profile.description}
                </p>
              </Fade> 
            

          <div className="btn-group">
            <button className="btn" onClick={handlePrev}>Prev</button>
            <button className="btn" onClick={handleNext}>Next</button>
          </div>
          
      </Modal>

    </div>
  )
}
export default App;

=================================================
useQuery (React Query)::

https://osusarak.medium.com/getting-started-with-usequery-react-query-9ea181c3dd47

==================================================

HOW TO MAKE A NUMBER COUNT UP FROM ZERO TO SAID AMOUNT LIKE 45/345 etc.
======================================================================
Here if the text is like "3 Minutes" then also the number will move from 0 to 3 but text will remain static.
"react-countup"  is used for moving the number from zero to 10/5.5/36000/3 as is shown in below phrases or texts.
"use-is-in-viewport" is a library that is used for tracking the DIV when its in view upon scrolling. Yoou just need to put "ref" there on that DIV.
usage:
  const [isInViewport, targetRef] = useIsInViewport();

<div ref={targetRef}>
this div is present somewhere very bottom in the webpage which is not in view currently.
</div>

Whenever this DIV is in viewport upon scroll then a flag variable "isInViewport" becomes true and based on this flag variable you can do anything 
like render a text.

sample code::
============

import React, {useState} from 'react'
import CountUp from 'react-countup';
import useIsInViewport from 'use-is-in-viewport';

const App = () => {
  const [statistics,] = useState(
    ["10", "5.5 million", "36000", "every 3 minutes"]
  )

  const [isInViewport, targetRef] = useIsInViewport();

  const checkInteger = (num) => {
    return Number.isInteger(num);
  }

  const getValue = (value) => {
    if(isNaN(value)){
      const extractedNumber = Number(value.replace(/[^0-9\.]+/g,""));
      const text = value;
      const txtArray = text.split(extractedNumber).map(el => el.trim()).filter(el => el.trim() !== "");
      // check for float number
      return txtArray.length === 1 ? (
        checkInteger(extractedNumber) ? (
          <CountUp start={0} end={extractedNumber} duration={2} suffix={` ${txtArray[0]}`} />
        ):(
          <CountUp start={0} end={extractedNumber} duration={2} suffix={` ${txtArray[0]}`} decimals={1} decimal="." />
        )
      ):(
        checkInteger(extractedNumber) ? (
          <CountUp start={0} end={extractedNumber} duration={2} prefix={`${txtArray[0]} `} suffix={` ${txtArray[1]}`} />
        ):(
          <CountUp start={0} end={extractedNumber} duration={2} prefix={`${txtArray[0]} `} suffix={` ${txtArray[1]}`} />
        )
      )      
    }
    else{
      return checkInteger(Number(value)) ? (
        <CountUp start={0} end={Number(value)} duration={2} />
      ):(
        <CountUp start={0} end={Number(value)} duration={2} decimals={1} decimal="." />
      )
    }
  }

  return (
    <div className="container">
       <h3>Application.........</h3>
       <div className="scroll-element">
       </div>
        
       <div className="scroll-container"  ref={targetRef}>
         {
           isInViewport && <div className="scrolx">
             {
               statistics?.map((stat, i) => {
                 return <p key={i}>{getValue(stat)} </p>;
               })
             }
           </div>
         }
          
       </div>

       <hr />
        
    </div>
  )
}


Scroll event from any nested down level component
=================================================

In case of nested component of any level ex: if a section div has header and mid section and footer component and 
we need to do something on scroll events even on footer component.  We need to understand that even though the footer component size on
webpage may be small but still we need to implement scroll on footer bcoz we are implementing scroll on WINDOW object that can be access from 
anywhere so we can do our stuff on footer based on scroll and the scroll refers to global scroll on the webpage not on footer component.

e.g:

<main>
	<header />
	<middleSection />
	<footer />
</main>

we can have scroll events from top to bottom defined in either header or middleSection or footer component and all will ensure full webpage scroll and if we have
to do something  in any particular component like changing background color or font size or changing the UI then we can easily do that. Only one thing that 
we need to define scroll events in that particular component only not any parent component.

const [detectScroll, setDetectScroll] = useState(false);
useEffect(() => {
   const handleScroll = () => {
	setDetectScroll(true);
   }
    window.addEventListener('scroll', handleScroll);
    return () => {
      window.removeEventListener('scroll', handleScroll);
    };
}, []);


Now we are DETECTING THE SCROLL based on a flag variable or state variable and we can do anything on the component based on this flag variable.



ReactJS Pagination library::
==========================

https://www.npmjs.com/package/react-paginate

Note: in github for huub challenge also implemented and its very simple.

Note:
This package does not have a css so for having css in this, we need to either write css or use bootstrap css of pagination component.
Or install bootstrap in some random project and take the css from there and paste it for your projects css file.

This package is not responsive. To make it responsive either manipulate "marginPagesDisplayed" and "pageRangeDisplayed"
based on resize event in reactJS.
Entire thing is displayed in :
https://github.com/arjun2010-ece/huub_challenge_react_pagination/blob/master/src/components/ProductList.js


Modal/Popup help
================

-> It is very very easy to use in any UI framework.

https://www.npmjs.com/package/react-responsive-modal
https://codesandbox.io/s/9jxp669j2o?file=/index.js:499-514




LIST OF MEDIUM WITH RADIOBOX
============================
ALL THE INPUT TYPE RADIO should have the same name if we want to select only one radio box.
and the condition for checked should be specific:
	checked={medium === 'book'} &  checked={medium === 'video'}
input will be checked only when states medium value === video.
Initial value is defined video here.
Here the imp variable is "medium" whose initial value is set to "".
Since its initial value is "" so no checked condn is satisfied and hence nothing checked.

HTML:
    const showMedium = () => (
        <React.Fragment>
            <div className="form-check ml-3">
                <label className="form-check-label">
                    <input
                        type="radio"
                        onClick={handleMediumClick}
                        checked={medium === 'video'}
                        value="video"
                        className="from-check-input"
                        name="medium"
                    />{' '}
                    Video
                </label>
            </div>

            <div className="form-check ml-3">
                <label className="form-check-label">
                    <input
                        type="radio"
                        onClick={handleMediumClick}
                        checked={medium === 'book'}
                        value="book"
                        className="from-check-input"
                        name="medium"
                    />{' '}
                    Book
                </label>
            </div>
        </React.Fragment>
    );

Handler::

   const handleMediumClick = e => {
        setState({ ...state, medium: e.target.value, success: '', error: '' });
    };



LIST OF CATEGORIES WITH CHECKBOX
================================
Mostly with checkbox and its handlers:

Html:
   // show categories > checkbox
    const showCategories = () => {
        return (
            loadedCategories &&
            loadedCategories.map((c, i) => (
                <li className="list-unstyled" key={c._id}>
                    <input type="checkbox" onChange={handleToggle(c._id)} className="mr-2 " />
                    <label className="form-check-label">{c.name}</label>
                </li>
            ))
        );
    };
    
Handler:
    // check if cid is present in empty array
    // if present then splice it, if not then push it.
    // check for the presence by indexOf() fn
    const handleToggle = c => () => {
        // return the first index or -1
        const clickedCategory = categories.indexOf(c);
        const all = [...categories];

        if (clickedCategory === -1) {
            all.push(c);
        } else {
            all.splice(clickedCategory, 1);
        }
        console.log('all >> categories', all);
        setState({ ...state, categories: all, success: '', error: '' });
    };



POST request to server with images along with check field data
==============================================================

credit_amount is from a text fields.
payment_type is radiobox data sending as name and value.
supportFiles is uploading images.

this.state = {
data: {
        credit_amount: 0,
        payment_type: {
          name: "bank_transfer",
          value: true
        },
        supportFiles: null
      },
}



handleSubmit() {
    const {
      credit_amount,
      payment_type: { name, value },
      supportFiles
    } = this.state.data;

    var fd = new FormData();
    fd.set("credit_amount", credit_amount);
    fd.set(name, value);
    fd.append("support_files", supportFiles);
    this.setState({ loading: true });
    axios
      .post("/admin/en/subscription/add_credit", fd, {
        headers: {
          "Content-Type": "multipart/form-data"
        }
      })
      .then(res => {
        this.setState({ loading: false });
        if (res.data.success) {
          this.props.displayAlertMessage(true, "credit");
          this.setState(
            {
              addCreditModalOpen: false
            },
            () => {
              window.scrollTo(0, 0);
            }
          );
        } else {
          this.setState(
            {
              addCreditModalOpen: true,
              largeFileSize: true
            },
            () => {
              this.props.displayAlertMessage(false, "credit");
            }
          );
        }
      })
      .catch(err => {
        console.log(err);
        this.setState({ addCreditModalOpen: false });
        this.props.displayAlertMessage(true, "support");
      });
  }



CHECK OBJECT COMPARISION WITH USE-EFFECT::
========================================

 useEffect(() => {
   if (startFlag && endFlag) {
      console.log("Both dated working...");
    }
  }, [startFlag,endFlag]);


 const handleDatesChanged = ({ startDate, endDate }) => {
    if (JSON.stringify(startDate) !== JSON.stringify(startDated)) {
      setStartFlag(true);
      setStartDated(startDate);
    }
    if (JSON.stringify(endDate) !== JSON.stringify(endDated)) {
      setEndFlag(true);
      setEndDated(endDate);
    }
  };


CHECK WIDTH OF BROWSER OR DEVICE THROUGH JAVASCRIPT
====================================================

Sure shot way of finding width of device be it mobile or laptop or desktop is::

var width = Math.max(window.screen.width, window.innerWidth);





REACT LAZY AND SUSPENSE IMPORTANT READ
========================================
https://blog.bitsrc.io/react-rendering-using-concurrent-mode-and-suspense-1600c574f996

App.js
import React, { Component, Suspense } from 'react';
const Hello = React.lazy(() => import("./components/Hello"));

function Wait() {
  return <div> Wait till it load... </div>;
}

class App extends Component {
  render() {
    return (
      <div className="container">
        <p>Its Application load....</p>
        <Suspense fallback={<Wait />}>
            <Hello val="Its lazy amigo" />
        </Suspense>
      </div>
    )
  }
}
export default App;


Hello.js
--------
import React from "react";
 
function Hello({ val }) {
  return <div>{val}</div>;
}
 
export default Hello;
==================================================


react-testing help:
===================
https://react-testing-examples.com/
https://github.com/sapegin/rtl-article-2019  ---very gud links
https://blog.sapegin.me/all/react-testing-3-jest-and-react-testing-library/
https://github.com/sapegin/jest-cheat-sheet#promises


React-testing-library end to end tutorial::
==========================================
https://github.com/kentcdodds/react-testing-library-course/blob/master/src/api.js


https://medium.com/free-code-camp/quick-guide-to-tdd-in-react-81888be67c64?
https://testing-library.com/docs/learning

further kent c todd codesandbox tutorial::
https://codesandbox.io/s/github/kentcdodds/react-testing-library-examples

https://react-testing-library-examples.netlify.com/
https://rafaelquintanilha.com/react-testing-library-common-scenarios/

https://github.com/rkotze/react-testing-library/tree/master/examples/__tests__
https://www.richardkotze.com/coding/
https://codesandbox.io/s/rl0wj028pp
https://github.com/testing-library/react-testing-library/issues/93

============================================================================
react testing library project video on hackernews api and styled components
============================================================================
https://www.youtube.com/watch?v=7DLRJj1YjvQ&t=6823s



form testing::
==============
https://kula.blog/posts/test_on_submit_in_react_testing_library/


variable utilisation--memory efficient using array
===================================================
 instead of using a function returning different things
 like below::
 
 Here function is allocating space for 4 variables every time function is called and its not good.
 function dateManipulation(){
 let a = new Date();
 let a = dateObject.getFullYear();
 let b = String(dateObject.getMonth() + 1).padStart(2, '0');
 let c = String(dateObject.getDate()).padStart(2, '0');
 return b;
 }
 
 the more optimised way in react is using array ::
 ----------------------------------------------------------------------
 put all the statements of above function inside an array like below::
  
 const dateObject = new Date(); // allocated only once and used multiple times like inside below array
 
 // here all those statments inside array are joined by empty space : ".join('')" to separate all those.
 const today = [dateObject.getFullYear(), String(dateObject.getMonth() + 1).padStart(2, '0'), String(dateObject.getDate()).padStart(2, '0')].join('');

its like result is YYYYMMDD or 20200823



Promise resolved inside useeffect
=================================
Best practice and avoid react warnings::
we need to use IIFE inside useEffect to resolve api request or promise::

useEffect(() => {
    (async () => {
      await getCachedWeather(today, props).then(data => setWeatherInfo(data) );
    })();
  },[]);




Aync destructuring when api called inside useEffect(BEST PRACTICES):
===================================================================

We cant do destructuring  for async api call inside udeEffect and particularly when promise is resolved inside useEffect,
then there is a diff way to achieve it inside useEffect.

const WeatherComponent = props =>  {  
  useEffect(() => { 
    //  CALL API---we need to resolve promise inside loadContent fn and then call it and use async-await like below,only way to
    // do it
    async function loadContent() {
      await getCachedWeather(today, props).then(data => setWeatherdata(data) );
    }
    loadContent();
  }, [today, props]);
  
  // the above useeffect can be broken down to an easy way like below(updated answer)::
  // its like calling an IIFE with async await(more classy)
   useEffect(() => {
    (async () => {
      await getCachedWeather(today, props).then(data => setWeatherInfo(data) ); // weatherInfo is set here
    })();
  },[]);

//setting state inside above useEffect
const [weatherInfo, setWeatherInfo] = useState(null);  

  // incase of api requests or props dependency use IF-ELSE condition to reduce rerender and improve app.
 if(weatherInfo){
 return (
    <div>
        <ul className="no-bullets weather">
      	    <li><i className="grey fa fa-info"></i> <span> {weatherInfo.current.weather[0].description}</span></li>
	    <li><i className="grey fa fa-info"></i>wind speed <span>  { weatherInfo.current.wind_speed}  m/s</span></li>
	    <li><i className="grey fa fa-info"></i>wind degrees <span> { weatherInfo.current.wind_deg}</span></li>
        </ul>
    </div>
  );
 }
 else{
    return ''
  }
}


Note for below code:::
--------------------
const todaysWeather = (
    	<ul className="no-bullets weather">
      	    <li><i className="grey fa fa-info"></i> <span> {weatherdata && weatherdata.current && weatherdata.current.weather[0].description}</span></li>
	    <li><i className="grey fa fa-info"></i>wind speed <span>  {weatherdata && weatherdata.current && weatherdata.current.wind_speed}  m/s</span></li>
	    <li><i className="grey fa fa-info"></i>wind degrees <span> {weatherdata && weatherdata.current && weatherdata.current.wind_deg}</span></li>
        </ul>
      );
the above code can be replaced by below: usage of Safe Navigation Operator (?.) or async operator

	const todaysWeather = (
    	<ul className="no-bullets weather">
      	    <li><i className="grey fa fa-info"></i> <span> { weatherdata?.current?.weather[0]?.description}</span></li>
	    <li><i className="grey fa fa-info"></i>wind speed <span>  { weatherdata?.current?.wind_speed}  m/s</span></li>
	    <li><i className="grey fa fa-info"></i>wind degrees <span> { weatherdata?.current?.wind_deg}</span></li>
        </ul>
      );
 or a better if else condition like below(ideal)::
 // here there is no need to check for individual conditions or safe navigations
if(weatherInfo){
 return (
    <div>
        <ul className="no-bullets weather">
      	    <li><i className="grey fa fa-info"></i> <span> {weatherInfo.current.weather[0].description}</span></li>
	    <li><i className="grey fa fa-info"></i>wind speed <span>  { weatherInfo.current.wind_speed}  m/s</span></li>
	    <li><i className="grey fa fa-info"></i>wind degrees <span> { weatherInfo.current.wind_deg}</span></li>
        </ul>
    </div>
  );
 }
 else{
    return ''
  }
 
 
 
Note:: 
since we cant destructure becoz of async nature so we need to check for conditions and then use it inside todaysWeather
condition.

inside api.js file
--------------------
it returns a promise to be resolved inside .then function done inside above useEffect.


import axios from "axios";

export const getCachedWeather = async ( today, props) => {
    // const resp = await axios.get(`https://api.openweathermap.org/data/2.5/onecall?lat=${props.center.lat}&lon=${props.center.lng}&appid=${process.env.REACT_APP_WEATHER_API_KEY}&units=metric`);    
    const cached_data = await getCache(today, props.trail_token)    
    if (cached_data) {        
        return cached_data
    } else {        
        const weather_data = await axios.get(`//api.openweathermap.org/data/2.5/weather/?lat=${props.center.lat}&lon=${props.center.lng}&cnt=5&appid=${process.env.REACT_APP_WEATHER_API_KEY}&units=metric`);
        setCache(weather_data.data, props.trail_token)        
        return weather_data.data;
    }
}

const getCache = async (today, token) => {
    try {
        const response = await axios.get(`${process.env.REACT_APP_API_ENDPOINT}/gb/storage/weather/${today}/${token}`);                
        return response.data
    } catch (error) {
        return false
    }
}

const setCache = ( weather_data, token) => {
    try {        
        axios.post(`${process.env.REACT_APP_API_ENDPOINT}/gb/storage/weather`, { weather: weather_data, trail_token: token });    
    } catch (error) {
        console.error("error caching data:")
    }
}
==============================================================


setting up react testing library::
==================================
https://dev.to/aromanarguello/getting-started-with-jest-react-testing-library-4nga

checking for two conditions in className::
=========================================
<h3 data-testid="item" className={ selected && selected.title === todo.title ? 'selected' :'' }>
  {todo.title}
</h3>

when selected exists then and then only check for selected.title === todo.title
and if its true then we have 'selected' classname else ''.

===============================
REACT_INTERNATIONALISATION
===============================
https://dev.to/ksushiva/how-to-translate-your-react-js-app-with-i18next-12mn

==========================================================
mimic setState() callback in react hooks
----------------------------------------

Stackoverflow link for better explanation::

https://stackoverflow.com/questions/60213779/replace-of-setstate-callback-in-react-hook-with-useeffect-hooks-for-complicated/60218834#60218834


If Else condn inside useEffect can help to mimic.
One of condition with default state will run for first time but with the condition we want our callback to occur usually with
flag variable helps to execute this scenario.

useEffect with something in dependency array will first run with default state conditions and everytime depency array 
variable changes but will execute only the code when particular condions inside ELSE block matches.


const App = () => {
  const [age, setAge] = useState(0);
  const [ageFlag, setAgeFlag] = useState(false);
  
  const updateAge = ()=>{
    setAgeFlag(false);
    setAge(age+1);
    setAgeFlag(true);
  };

  useEffect(() => {
    if(!ageFlag){
      console.log('effect called without change - by default');
    }
    else{
      console.log('effect called with change ');
    }
  }, [ageFlag,age]);
 
  return (
    <form>
      <h2>hooks demo.....</h2>
      <p>Drinking Age Checker</p>
      {age}
      {/* <input
        type="number"
        value={age} 
        onChange={updateAge}
      /> */}
      <button onClick={updateAge}>Text</button>
    </form>
  );
}


Datalist kind of project::
========================

//Text highlighting is left.

import React, { Component } from 'react';
import { render } from 'react-dom';
import Hello from './Hello';
import './style.css';

class App extends Component {
  constructor() {
    super();
    this.state = {
      name: 'React',
      filterArray: []
    };
  }
  onChange=(e)=>{
    let inpText = e.target.value.toLowerCase();
    let FixedArray = ["Arjun","Joao","Arjan","Arpun","Joala","joinkl"];
    let filterArray = FixedArray.filter(elem => {
      if(elem.toLowerCase().includes(inpText)){
        return elem;
      };
    });
    this.setState({filterArray})
    console.log(filterArray);
  }

  render() {
  let arrayContent = this.state.filterArray.map(elem => (
            <p>{elem}</p>
          ));
    return (
      <div>
        <Hello name={this.state.name} />
        <p>
          Start editing to see some magic happen :)
        </p>
        <input type="text" name="lists" onChange={this.onChange}/>
        {
          this.state.filterArray.length > 0 ? arrayContent: <p>"No reccords found"</p>
        }
      </div>
    );
  }
}

render(<App />, document.getElementById('root'));




Generate Id in React::
=====================

Use uuid library 

or

maxId = + new Date() // + sign gives numeric values of Date e.g 1571594550970(epoch value) i.e hour minute second millisecond.

REACT CONTROLLED AND UNCTROLLED ISSUE:::
=========================================
issue is resolved by using //instead of value use defaultValue in input or select tag.

this.state={
     username: '',
     password: '',
     passwordConfirmation: '',
     timezone: ''
  };
  
   onChange=(e)=>{
  this.setState({ [e.target.name]: e.target.value});
 }
 
  <form onSubmit={this.onSubmit}>
     <h1>Join our community</h1>

     <div className="form-group">
       <label className="control-label">Username</label>
       <input 
          type="text"
          name="username"
          defaultValue={this.state.username}  //instead of value use defaultValue
          onChange={this.onChange}
          className="form-control"
         />
     </div>

     <div className="form-group">
       <label className="control-label">Email</label>
       <input 
          type="text"
          name="email"
          defaultValue={this.state.email} //instead of value use defaultValue
          onChange={this.onChange}
          className="form-control"
         />
     </div>
     
     </form>




CONDITIONALLY APPLYING CSS IN REACT COMPONENT or JS:::
======================================================
One more way is to use like this in className::
className={"form-control" + (conditionalClass ? ` ${conditionalClass}`: "")};

Ex1:

let completeClass = project.completed ? 'project-completed' : ''; //conditionall class

<li className={"project-item " + completeClass}>
       Conditionally apply css
</li>

Within curly brace {}, put one class within double quote(e.g "project-item ")
and add the variable (used for conditional class).

Ex2:
<div className={'card-answer ' + (this.state.reveal ? 'text-revealed':'text-hidden')}>

.text-hidden{
 visibility: hidden;
}

.text-revealed{
 visibility: visible;
}

When to use React “componentDidUpdate” lifecycle method?
==========================================================

whenever the setState() is called and if it looks like something below:

this.setState({
      firstName: this.props.profile.firstName, ///if there is this.props in setState()
      lastName: this.props.profile.lastName,
      emailId: this.props.profile.emailId
   })

Then componentDidUpdate() is used as below:

 updateState(){
   this.setState({
      firstName: this.props.profile.firstName,
      lastName: this.props.profile.lastName,
      emailId: this.props.profile.emailId
   })
  }
  componentDidUpdate(prevProps) {
   // Typical usage (don't forget to compare props):
   if (this.props.profile !== prevProps.profile) {
     // Do stuff
     this.updateState();
   }
 }

==============================================================================
To read from input tags ,we can either use ref only or value and onChange together
BUTTTTTTT we can use "defaultValue"

For edit purpose we can use ref and defaultValue together on input tags
===============================================================================

Convert Objects into arrays for react purpose
============================================

streams:Object.values(state.streams) // It will take all all values of objects and convert into arrays of values


Convert arrays of objects into Objects for react purpose
============================================

_.mapKeys( action.payload, 'id') // takes each object of action.payload and covert into objects
//finally is object creation.

========================================================================
Browser Router internally creates history object which looks for address change in browser address bar'which is good for 
normal navigation but for programmatic navigation or redirection  its not good.

For that we need to use normal Router and give it a prop history and we need to create a history.js file too.

history.js
=========
import { createBrowserHistory } from 'history'; 
export default createBrowserHistory();




Action creators has second argument getState
============================================

export const fetchPostsAndUser = ()=> async (dispatch, getState) => {
    await dispatch(fetchPosts());
    const userIds =  _.uniq(_.map(getState().posts,'userId'));
    console.log(userIds);
}

// getState gets all the store data in action creators
// getState().posts gets posts reducers data.

//One action creator if need to call other then it should be called inside dispatch() otherwise it will not work.


Memoizong function
==================
Memoizong function from underscore js is helpul and avoid making an api request multiple times(overfetching) like for a single id, it 
will make exactly one times but the downside is that if some changes is done on the api side then it will not again make a
request to that api.

import _ from 'lodash';
import jsonPlaceholder from '../apis/jsonPlaceholder';

export const fetchUser = (id) => dispatch => _fetchUser(id, dispatch); //inner function should be memoized

const _fetchUser = _.memoize( async (id, dispatch) =>
{
    const response = await jsonPlaceholder.get(`/users/${id}`);

    dispatch({ type: 'FETCH_USER', payload: response.data });
});


Class component props accessible inside mapStateToProps
=======================================================
class UserHeader extends Component {
  //its props are accessed as this.props.user something lyk that
}

const mapStateToProps = (state, ownProps) => {
    return { user: state.users.find(user => user.id === ownProps.userId) };
}

But inside mapStateToProps which is outside the scope of class component we can have access to props of class through 
"ownProps" that is used for computation purpose since component is mostly not suited for computation.




Empty values of variables while making api request
=================================================
case 1:
======
componentDidMount(){
        this.props.fetchUser(this.props.userId); //making api request here
    }
    render() {
        const user = this.props.users.find(user => user.id === this.props.userId);
        if(!user){
            return null;
        }
        return <div>-{user.name}</div> 
    }

//First time render function runs, there is no user but we only have to give that conditional if the variable(user) 
is mentioned inside render() but if we use a function outside render then we dont need to give conditionals


case 2:
======

 componentDidMount(){
        this.props.fetchPosts(); ///making api request here
    }

    renderList(){
        return this.props.posts.map(post => {
        return (
            <div className="item" key={post.id}>
                <i className = "large middle aligned icon user"/>
                <div className="content">
                    <div className="description">
                        <h2>{post.title}</h2>
                        <p>{post.body}</p>
                    </div>
                    <UserHeader userId={post.userId} />
                </div>
            </div>
            );
        });
    }

    render() { 
        return (
            <div className="ui relaxed divided list">
                { this.renderList() }
            </div>
        );
    }

renderList() has the results of api request that is outside render() so we willnot put conditionals inside render(),although
we are using renderList() inside render().




React Lifecycle Methods:::
==========================
https://www.codingame.com/playgrounds/8747/react-lifecycle-methods-render-and-componentdidmount

componentDidMount() method
==============================
As the name suggests, after all the elements of the page is rendered correctly, this method is called. After the markup is 
set on the page, this technique called by React itself to either fetch the data from An External API or perform some unique 
operations which need the JSX elements.

componentDidMount() method is the perfect place, where we can call the setState() method to change the state of our 
application and render() the updated data loaded JSX. 

componentWillMount() method
===========================
componentWillMount() method is the least used lifecycle method and called before any HTML element is rendered. 




Very important link for validating react redux form using formik,Yup and MATERIAL-UIs
=======================================================================================
https://dev.to/finallynero/react-form-using-formik-material-ui-and-yup-2e8h



If there is single props then we can directly use that props name without destructuring
=======================================================================================

const SongDetail = ({song}) => {  //here input shd be props in functional component but instead name of props used
    if(song){
        return (
            <div>
                <h1>{song.title}</h1>
                <h3>{song.duration}</h3>
            </div>
        )
    }
    return (
        <div>
            Song Detail
        </div>
    )
}

const mapStateToProps = (state) => {
    return {
        song: state.selectedSong   //props is song
    }
}


Binding form input elements with the single onChange
====================================================

import React, { Component } from 'react'

class Postform extends Component {
  constructor(props){
      super(props);
      this.state={
          title:'',
          body:''
      };

      this.onChange = this.onChange.bind(this);
  }
  onChange(e){
      this.setState({ [e.target.name]: e.target.value}); //single onChange handling both input and textarea element
  }                                                      // here name of input element comes handy
  render() {
    return (
      <div>
        <h1>Add Posts</h1>
        <form>
            <div>
                <label>Title: </label><br/>
                <input type="text" name="title" onChange={this.onChange} // here name of input element is given
                    value={this.state.title}/>
            </div><br/>
            <div>
                <label>Body: </label><br/>
                <textarea name="body" onChange={this.onChange} // here name of input element is given
                value={this.state.body}/>
            </div><br/>
            <button type="submit">Add</button>
        </form>
      </div>
    )
  }
}
=============================================================================
  FETCH API USAGE IN REACT  ----GET/POST methods.

=============================================================================

GET::
=====

fetch('https://jsonplaceholder.typicode.com/posts')
        .then(res=>res.json())
        .then(data=> this.setState({posts:data}));
    }
    
POST:::::
=========
onSubmit(e){  //on submit of form
      e.preventDefault();
      const post = {
          title: this.state.title,
          body: this.state.body
      }
      fetch('https://jsonplaceholder.typicode.com/posts',{
          method:'POST',
          headers:{
              'content-type':'application/json'  //what kind of data we are posting
          },
          body: JSON.stringify(post)  //actual content
      })
       .then(res => res.json())
       .then(data=> console.log(data)); //it will give the posted data back
  }





