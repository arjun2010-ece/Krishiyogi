Memoizong function
==================
Memoizong function from underscore js is helpul and avoid making an api request multiple times like for a single id, it 
will make exactly one times but the downside is that if some changes is done on the api side then it will not again make a
request to that api.

import _ from 'lodash';
import jsonPlaceholder from '../apis/jsonPlaceholder';

export const fetchUser = (id) => dispatch => _fetchUser(id, dispatch); //inner function should be memoized

const _fetchUser = _.memoize( async (id, dispatch) =>
{
    const response = await jsonPlaceholder.get(`/users/${id}`);

    dispatch({ type: 'FETCH_USER', payload: response.data });
});


Class component props accessible inside mapStateToProps
=======================================================
class UserHeader extends Component {
  //its props are accessed as this.props.user something lyk that
}

const mapStateToProps = (state, ownProps) => {
    return { user: state.users.find(user => user.id === ownProps.userId) };
}

But inside mapStateToProps which is outside the scope of class component we can have access to props of class through 
"ownProps" that is used for computation purpose since component is mostly not suited for computation.




Empty values of variables while making api request
=================================================
case 1:
======
componentDidMount(){
        this.props.fetchUser(this.props.userId); //making api request here
    }
    render() {
        const user = this.props.users.find(user => user.id === this.props.userId);
        if(!user){
            return null;
        }
        return <div>-{user.name}</div> 
    }

//First time render function runs, there is no user but we only have to give that conditional if the variable(user) 
is mentioned inside render() but if we use a function outside render then we dont need to give conditionals


case 2:
======

 componentDidMount(){
        this.props.fetchPosts(); ///making api request here
    }

    renderList(){
        return this.props.posts.map(post => {
        return (
            <div className="item" key={post.id}>
                <i className = "large middle aligned icon user"/>
                <div className="content">
                    <div className="description">
                        <h2>{post.title}</h2>
                        <p>{post.body}</p>
                    </div>
                    <UserHeader userId={post.userId} />
                </div>
            </div>
            );
        });
    }

    render() { 
        return (
            <div className="ui relaxed divided list">
                { this.renderList() }
            </div>
        );
    }

renderList() has the results of api request that is outside render() so we willnot put conditionals inside render(),although
we are using renderList() inside render().




React Lifecycle Methods:::
==========================
https://www.codingame.com/playgrounds/8747/react-lifecycle-methods-render-and-componentdidmount

componentDidMount() method
==============================
As the name suggests, after all the elements of the page is rendered correctly, this method is called. After the markup is 
set on the page, this technique called by React itself to either fetch the data from An External API or perform some unique 
operations which need the JSX elements.

componentDidMount() method is the perfect place, where we can call the setState() method to change the state of our 
application and render() the updated data loaded JSX. 

componentWillMount() method
===========================
componentWillMount() method is the least used lifecycle method and called before any HTML element is rendered. 




Very important link for validating react redux form using formik,Yup and MATERIAL-UIs
=======================================================================================
https://dev.to/finallynero/react-form-using-formik-material-ui-and-yup-2e8h



If there is single props then we can directly use that props name without destructuring
=======================================================================================

const SongDetail = ({song}) => {  //here input shd be props in functional component but instead name of props used
    if(song){
        return (
            <div>
                <h1>{song.title}</h1>
                <h3>{song.duration}</h3>
            </div>
        )
    }
    return (
        <div>
            Song Detail
        </div>
    )
}

const mapStateToProps = (state) => {
    return {
        song: state.selectedSong   //props is song
    }
}


Binding form input elements with the single onChange
====================================================

import React, { Component } from 'react'

class Postform extends Component {
  constructor(props){
      super(props);
      this.state={
          title:'',
          body:''
      };

      this.onChange = this.onChange.bind(this);
  }
  onChange(e){
      this.setState({ [e.target.name]: e.target.value}); //single onChange handling both input and textarea element
  }                                                      // here name of input element comes handy
  render() {
    return (
      <div>
        <h1>Add Posts</h1>
        <form>
            <div>
                <label>Title: </label><br/>
                <input type="text" name="title" onChange={this.onChange} // here name of input element is given
                    value={this.state.title}/>
            </div><br/>
            <div>
                <label>Body: </label><br/>
                <textarea name="body" onChange={this.onChange} // here name of input element is given
                value={this.state.body}/>
            </div><br/>
            <button type="submit">Add</button>
        </form>
      </div>
    )
  }
}
=============================================================================
  FETCH API USAGE IN REACT  ----GET/POST methods.

=============================================================================

GET::
=====

fetch('https://jsonplaceholder.typicode.com/posts')
        .then(res=>res.json())
        .then(data=> this.setState({posts:data}));
    }
    
POST:::::
=========
onSubmit(e){  //on submit of form
      e.preventDefault();
      const post = {
          title: this.state.title,
          body: this.state.body
      }
      fetch('https://jsonplaceholder.typicode.com/posts',{
          method:'POST',
          headers:{
              'content-type':'application/json'  //what kind of data we are posting
          },
          body: JSON.stringify(post)  //actual content
      })
       .then(res => res.json())
       .then(data=> console.log(data)); //it will give the posted data back
  }





