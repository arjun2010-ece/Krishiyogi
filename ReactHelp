Very important link of a simple classy project built with react and react-bootstrap
https://medium.com/bb-tutorials-and-thoughts/how-to-implement-different-layouts-in-react-38f3686b3388


React-testing-library end to end tutorial::
==========================================
https://github.com/kentcdodds/react-testing-library-course/blob/master/src/api.js


https://medium.com/free-code-camp/quick-guide-to-tdd-in-react-81888be67c64?
https://testing-library.com/docs/learning

further kent c todd codesandbox tutorial::
https://codesandbox.io/s/github/kentcdodds/react-testing-library-examples

https://react-testing-library-examples.netlify.com/
https://rafaelquintanilha.com/react-testing-library-common-scenarios/

https://github.com/rkotze/react-testing-library/tree/master/examples/__tests__
https://www.richardkotze.com/coding/
https://codesandbox.io/s/rl0wj028pp
https://github.com/testing-library/react-testing-library/issues/93

form testing::
==============
https://kula.blog/posts/test_on_submit_in_react_testing_library/

setting up react testing library::
==================================
https://dev.to/aromanarguello/getting-started-with-jest-react-testing-library-4nga

checking for two conditions in className::
=========================================
<h3 data-testid="item" className={ selected && selected.title === todo.title ? 'selected' :'' }>
  {todo.title}
</h3>

when selected exists then and then only check for selected.title === todo.title
and if its true then we have 'selected' classname else ''.

===============================
REACT_INTERNATIONALISATION
===============================
https://dev.to/ksushiva/how-to-translate-your-react-js-app-with-i18next-12mn



Datalist kind of project::
========================

//Text highlighting is left.

import React, { Component } from 'react';
import { render } from 'react-dom';
import Hello from './Hello';
import './style.css';

class App extends Component {
  constructor() {
    super();
    this.state = {
      name: 'React',
      filterArray: []
    };
  }
  onChange=(e)=>{
    let inpText = e.target.value.toLowerCase();
    let FixedArray = ["Arjun","Joao","Arjan","Arpun","Joala","joinkl"];
    let filterArray = FixedArray.filter(elem => {
      if(elem.toLowerCase().includes(inpText)){
        return elem;
      };
    });
    this.setState({filterArray})
    console.log(filterArray);
  }

  render() {
  let arrayContent = this.state.filterArray.map(elem => (
            <p>{elem}</p>
          ));
    return (
      <div>
        <Hello name={this.state.name} />
        <p>
          Start editing to see some magic happen :)
        </p>
        <input type="text" name="lists" onChange={this.onChange}/>
        {
          this.state.filterArray.length > 0 ? arrayContent: <p>"No reccords found"</p>
        }
      </div>
    );
  }
}

render(<App />, document.getElementById('root'));




Generate Id in React::
=====================

Use uuid library 

or

maxId = + new Date() // + sign gives numeric values of Date e.g 1571594550970(epoch value) i.e hour minute second millisecond.

REACT CONTROLLED AND UNCTROLLED ISSUE:::
=========================================
issue is resolved by using //instead of value use defaultValue in input or select tag.

this.state={
     username: '',
     password: '',
     passwordConfirmation: '',
     timezone: ''
  };
  
   onChange=(e)=>{
  this.setState({ [e.target.name]: e.target.value});
 }
 
  <form onSubmit={this.onSubmit}>
     <h1>Join our community</h1>

     <div className="form-group">
       <label className="control-label">Username</label>
       <input 
          type="text"
          name="username"
          defaultValue={this.state.username}  //instead of value use defaultValue
          onChange={this.onChange}
          className="form-control"
         />
     </div>

     <div className="form-group">
       <label className="control-label">Email</label>
       <input 
          type="text"
          name="email"
          defaultValue={this.state.email} //instead of value use defaultValue
          onChange={this.onChange}
          className="form-control"
         />
     </div>
     
     </form>




CONDITIONALLY APPLYING CSS IN REACT COMPONENT or JS:::
======================================================
Ex1:

let completeClass = project.completed ? 'project-completed' : ''; //conditionall class

<li className={"project-item " + completeClass}>
       Conditionally apply css
</li>

Within curly brace {}, put one class within double quote(e.g "project-item ")
and add the variable (used for conditional class).

Ex2:
<div className={'card-answer ' + (this.state.reveal ? 'text-revealed':'text-hidden')}>

.text-hidden{
 visibility: hidden;
}

.text-revealed{
 visibility: visible;
}

When to use React “componentDidUpdate” lifecycle method?
==========================================================

whenever the setState() is called and if it looks like something below:

this.setState({
      firstName: this.props.profile.firstName, ///if there is this.props in setState()
      lastName: this.props.profile.lastName,
      emailId: this.props.profile.emailId
   })

Then componentDidUpdate() is used as below:

 updateState(){
   this.setState({
      firstName: this.props.profile.firstName,
      lastName: this.props.profile.lastName,
      emailId: this.props.profile.emailId
   })
  }
  componentDidUpdate(prevProps) {
   // Typical usage (don't forget to compare props):
   if (this.props.profile !== prevProps.profile) {
     // Do stuff
     this.updateState();
   }
 }

==============================================================================
To read from input tags ,we can either use ref only or value and onChange together
BUTTTTTTT we can use "defaultValue"

For edit purpose we can use ref and defaultValue together on input tags
===============================================================================

Convert Objects into arrays for react purpose
============================================

streams:Object.values(state.streams) // It will take all all values of objects and convert into arrays of values


Convert arrays of objects into Objects for react purpose
============================================

_.mapKeys( action.payload, 'id') // takes each object of action.payload and covert into objects
//finally is object creation.

========================================================================
Browser Router internally creates history object which looks for address change in browser address bar'which is good for 
normal navigation but for programmatic navigation or redirection  its not good.

For that we need to use normal Router and give it a prop history and we need to create a history.js file too.

history.js
=========
import { createBrowserHistory } from 'history'; 
export default createBrowserHistory();




Action creators has second argument getState
============================================

export const fetchPostsAndUser = ()=> async (dispatch, getState) => {
    await dispatch(fetchPosts());
    const userIds =  _.uniq(_.map(getState().posts,'userId'));
    console.log(userIds);
}

// getState gets all the store data in action creators
// getState().posts gets posts reducers data.

//One action creator if need to call other then it should be called inside dispatch() otherwise it will not work.


Memoizong function
==================
Memoizong function from underscore js is helpul and avoid making an api request multiple times(overfetching) like for a single id, it 
will make exactly one times but the downside is that if some changes is done on the api side then it will not again make a
request to that api.

import _ from 'lodash';
import jsonPlaceholder from '../apis/jsonPlaceholder';

export const fetchUser = (id) => dispatch => _fetchUser(id, dispatch); //inner function should be memoized

const _fetchUser = _.memoize( async (id, dispatch) =>
{
    const response = await jsonPlaceholder.get(`/users/${id}`);

    dispatch({ type: 'FETCH_USER', payload: response.data });
});


Class component props accessible inside mapStateToProps
=======================================================
class UserHeader extends Component {
  //its props are accessed as this.props.user something lyk that
}

const mapStateToProps = (state, ownProps) => {
    return { user: state.users.find(user => user.id === ownProps.userId) };
}

But inside mapStateToProps which is outside the scope of class component we can have access to props of class through 
"ownProps" that is used for computation purpose since component is mostly not suited for computation.




Empty values of variables while making api request
=================================================
case 1:
======
componentDidMount(){
        this.props.fetchUser(this.props.userId); //making api request here
    }
    render() {
        const user = this.props.users.find(user => user.id === this.props.userId);
        if(!user){
            return null;
        }
        return <div>-{user.name}</div> 
    }

//First time render function runs, there is no user but we only have to give that conditional if the variable(user) 
is mentioned inside render() but if we use a function outside render then we dont need to give conditionals


case 2:
======

 componentDidMount(){
        this.props.fetchPosts(); ///making api request here
    }

    renderList(){
        return this.props.posts.map(post => {
        return (
            <div className="item" key={post.id}>
                <i className = "large middle aligned icon user"/>
                <div className="content">
                    <div className="description">
                        <h2>{post.title}</h2>
                        <p>{post.body}</p>
                    </div>
                    <UserHeader userId={post.userId} />
                </div>
            </div>
            );
        });
    }

    render() { 
        return (
            <div className="ui relaxed divided list">
                { this.renderList() }
            </div>
        );
    }

renderList() has the results of api request that is outside render() so we willnot put conditionals inside render(),although
we are using renderList() inside render().




React Lifecycle Methods:::
==========================
https://www.codingame.com/playgrounds/8747/react-lifecycle-methods-render-and-componentdidmount

componentDidMount() method
==============================
As the name suggests, after all the elements of the page is rendered correctly, this method is called. After the markup is 
set on the page, this technique called by React itself to either fetch the data from An External API or perform some unique 
operations which need the JSX elements.

componentDidMount() method is the perfect place, where we can call the setState() method to change the state of our 
application and render() the updated data loaded JSX. 

componentWillMount() method
===========================
componentWillMount() method is the least used lifecycle method and called before any HTML element is rendered. 




Very important link for validating react redux form using formik,Yup and MATERIAL-UIs
=======================================================================================
https://dev.to/finallynero/react-form-using-formik-material-ui-and-yup-2e8h



If there is single props then we can directly use that props name without destructuring
=======================================================================================

const SongDetail = ({song}) => {  //here input shd be props in functional component but instead name of props used
    if(song){
        return (
            <div>
                <h1>{song.title}</h1>
                <h3>{song.duration}</h3>
            </div>
        )
    }
    return (
        <div>
            Song Detail
        </div>
    )
}

const mapStateToProps = (state) => {
    return {
        song: state.selectedSong   //props is song
    }
}


Binding form input elements with the single onChange
====================================================

import React, { Component } from 'react'

class Postform extends Component {
  constructor(props){
      super(props);
      this.state={
          title:'',
          body:''
      };

      this.onChange = this.onChange.bind(this);
  }
  onChange(e){
      this.setState({ [e.target.name]: e.target.value}); //single onChange handling both input and textarea element
  }                                                      // here name of input element comes handy
  render() {
    return (
      <div>
        <h1>Add Posts</h1>
        <form>
            <div>
                <label>Title: </label><br/>
                <input type="text" name="title" onChange={this.onChange} // here name of input element is given
                    value={this.state.title}/>
            </div><br/>
            <div>
                <label>Body: </label><br/>
                <textarea name="body" onChange={this.onChange} // here name of input element is given
                value={this.state.body}/>
            </div><br/>
            <button type="submit">Add</button>
        </form>
      </div>
    )
  }
}
=============================================================================
  FETCH API USAGE IN REACT  ----GET/POST methods.

=============================================================================

GET::
=====

fetch('https://jsonplaceholder.typicode.com/posts')
        .then(res=>res.json())
        .then(data=> this.setState({posts:data}));
    }
    
POST:::::
=========
onSubmit(e){  //on submit of form
      e.preventDefault();
      const post = {
          title: this.state.title,
          body: this.state.body
      }
      fetch('https://jsonplaceholder.typicode.com/posts',{
          method:'POST',
          headers:{
              'content-type':'application/json'  //what kind of data we are posting
          },
          body: JSON.stringify(post)  //actual content
      })
       .then(res => res.json())
       .then(data=> console.log(data)); //it will give the posted data back
  }





